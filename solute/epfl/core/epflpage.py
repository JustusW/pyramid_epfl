# coding: utf-8

import pyramid
import epflcomponentbase, epfltransaction, epflclient
import types
import string

from solute.epfl import json
from solute.epfl.jinja import jinja_helpers

from solute.epfl.core import epflclient, epflutil

def dummy_decorator(func):
    return func

class Page(object):

    """
    Container for the components of the page.

    The parameter "name" must be unique for the complete application!

    There are three response-modes:
    - full-page: a complete html-page (including <script>-tags) are returned and rendered by the browser.
                 This is normally requested by a link (GET) or a submit (POST)

    - event-queue-response: multiple js-snippets are returned and evaluted at client side.
                            This is requested by a epfl.send(...) request from the client side.

    - ajax-json-response: a single json-string returned to an manually created ajax-request.
                          (eventually generated by a js-library, called on the client by epfl.ajax_request(...) )
    """

    asset_spec = "solute.epfl:static"

    js_name = ["js/jquery-1.8.2.min.js",
               "js/jquery-ui.js",
               "js/epfl.js",
               "js/epflcomponentbase.js",
               "js/json2-min.js"]

    css_name = ["css/epfl.css",
                "css/jquery-ui-lightness/jquery-ui-1.8.23.custom.css"]


    name = None # the logical name of this page
    template = None # the name of the template used to render this page


    def __init__(self, request):

        self.request = request
        self.response = epflclient.Response(request)

        self.data = {"css_imports": self.get_css_imports,
                     "js_imports": self.get_js_imports}  # additional variables for page
                                                         # use it, by assigning directly to this dictionary:
                                                         # e.g.
                                                         # page.data["something"] = some_object

        self.components = {} # all registered components of this page
        env = request.get_epfl_jinja2_environment()
        self.jinja_template = env.get_template(self.template)

        self.jinja_template.module # this access triggers the parsing of the template
                                   # this is neccessary because this parsing
                                   # collects additional meta-data from the template via
                                   # the epfl-jinja-component-extension (jinja_extensions.py)

        request.register_template_usage(self.template, self) # tells the request which page is in use

        if not self.name:
            self.name = self.__class__.__name__

        self.transaction = request.get_transaction()



    def __call__(self):
        """
        The method that gets called from the outside framework to diplay this page.

        [request-processing-flow]
        """


        self.setup_components()

        if self.handle_ajax_request():
            out = self.response.render_ajax_response()
        else:
            self.handle_submit_request()
            out = self.render()

        self.done()

        return pyramid.response.Response(body = out.encode("utf-8"), 
                                         content_type = "text/html; charset=utf-8", 
                                         status = 200) # todo


    def done(self):
        for compo_obj in self.components.values():
            compo_obj.finalize()

    def get_name(self):
        return self.name

    def __setattr__(self, key, value):
        """ This is the way, the components get thier name:
        By assigning the components as attributes to the page, we can register them here as components,
        and we can tell the components thier id (which is thier attribute-name).
        """
        self.__dict__[key] = value # regul√§r im Python-Objekt speichern

        if isinstance(value, epflcomponentbase.ComponentBase):
            self.components[key] = value
            value.set_component_id(key)
            value.set_page_obj(self)


    def get_jinja_template_extra_data(self):
        """ Returns the data accumulated by the jinja-epfl-component-extension (jinja_extensions.py).
        There is:

        {
           "compo_js_parts": all javascript-parts of all inlined components on this page.
        }

        """
        return __svc__.jinja.env.epfl_compoext_data[self.template]

    def get_page_init_js(self):
        """ returns a js-snipped which initializes the page. called only once per page """

        opts = {"tid": self.transaction.get_id()}

        return "epfl.init_page(" + json.encode(opts) + ")"

    def get_template_ctx(self):
        """ Returns a freshly created dict with all the global variables for the template rendering """

        ctx = {"epfl": {"scroll_pos": self.request.params.get("epfl_scroll_pos", "")}}
        ctx.update(self.components)
        ctx.update(self.data)

        return ctx

    def get_template_reflection_info(self):
        """ Returns the reflection info for the template of this page. Duh.
        """
        env = self.request.get_epfl_jinja2_environment()
        return env.get_reflection_info(self.jinja_template)

    def render(self):
        """ Is called in case of a "full-page-request" to return the complete page """

##   todo     self.request.assert_page_access(page_obj=self)

        self.add_js_response(self.get_page_init_js())

        epflutil.add_extra_contents(self.response, obj = self)

        # pre-render all components
        for component_name, component_obj in self.components.items():
            component_obj.pre_render()

        # exclusive extra-content
        exclusive_extra_content = self.response.get_exclusive_extra_content()

        # main-content
        if exclusive_extra_content:
            out = exclusive_extra_content
        else:
            ctx = self.get_template_ctx()
            out = self.response.render_jinja(self.jinja_template, **ctx)

        return out

    def handle_transaction(self):
        """ This method is called just before the event-handling takes place.
        It calles the init_transaction-methods of all components, that the event handlers have
        a complete setup transaction-state.

        [request-processing-flow]
        """

        transaction = self.request.get_transaction()

        for cid, compo in self.components.items():
            if cid + "$__inited__" not in transaction:
                transaction[cid + "$__inited__"] = True
                compo.init_transaction()

        for cid, compo in self.components.items():
            compo.setup_component()




    def handle_ajax_request(self):
        """ Is called by the view-controller directly after the definition of all components (self.setup_components).
        Returns "True" if we are in a ajax-request. self.render_ajax_response must be called in this case.
        A "False" means we have a full-page-request. In this case self.render must be called.

        [request-processing-flow]
        """

        if not self.request.is_xhr:
            return False

        self.handle_transaction()

        ajax_queue = self.request.json_body["q"]
        for event in ajax_queue:

            event_type = event["t"]

            if event_type == "ce": # component-event
                event_id = event["id"]
                cid = event["cid"]
                event_name = event["e"]
                event_params = event["p"]

                component_obj = self.components[cid]
                component_obj.handle_event(event_name, event_params)

            else:
                raise Exception, "Unknown ajax-event: " + repr(event)

        for cid, compo in self.components.items():
            compo.after_event_handling()


        for cid, compo_obj in self.components.items():
            if compo_obj.is_visible(check_parents = True):
                redraw_parts = compo_obj.get_redraw_parts()
                if redraw_parts:
                    js = "epfl.replace_component('{cid}', {parts})".format(cid = cid,
                                                                           parts = json.encode(redraw_parts))
                    self.add_js_response(js)
            else:
                self.add_js_response("epfl.hide_component('{cid}')".format(cid = cid))


        return True


    def handle_submit_request(self):
        """ Handles the "normal" submit-request which is normally a GET or a POST request to the page.
        This is the couterpart to the self.handle_ajax_request() which should be called first and if it returns
        False should be called.

        Example:

        if page.handle_ajax_request(json):
            return page.response.render_ajax_response()
        else:
            page.handle_submit_request()

        It calls the handle_submit-method of all components in this page.
        """

        self.handle_transaction()

        for component_name, component_obj in self.components.items():
            component_obj.handle_submit(dict(self.request.params))

        for cid, compo in self.components.items():
            compo.after_event_handling()

    def add_js_response(self, js_string):
        """ Adds the js either to the ajax-response or to the bottom of the page - depending of the type of the request """
        js_string += ";"
        if self.request.is_xhr:
            self.response.add_ajax_response(js_string)
        else:
            self.response.add_extra_content(epflclient.JSBlockContent(js_string))

    def show_fading_message(self, msg, typ = "info"):
        """ Shows a message to the user. The message is non evasive - it will show up and fade away nicely.
        typ = "info" | "ok" | "error"
        """

        js = "epfl.show_fading_message(%s,%s)" % (json.encode(msg), json.encode(typ))

        self.add_js_response(js)

    def show_message(self, msg, typ):
        """
        Displays a simple alert box to the user.
        typ = "info" | "ok" | "error"
        """
        js = "alert(%s)" % (json.encode(msg),)
        self.add_js_response(js)



    def get_css_imports(self):
        """ This function delivers the <style src=...>-tags for all stylesheets needed by this page and it's components.
        It is available in the template by the jinja-variable {{ css_imports() }}
        """
        return self.response.render_extra_content(target = "head")

    def get_js_imports(self):
        """ This function delivers the <script src=...>-tags for all js needed by this page and it's components.
        Additionally it delivers all generated js-snippets from the components or page.
        It is available in the template by the jinja-variable {{ js_imports() }}
        """

        # rendering all JS-parts of the components
        for compo_obj in self.components.values():
            if compo_obj.is_rendered:
                init_js = compo_obj.get_js_part()
                init_js = epflclient.JSBlockContent(init_js)
                self.response.add_extra_content(init_js)

        return self.response.render_extra_content(target = "footer")

    def jump(self, target, **page_params):
        """ Sends a redirect to the given target.
        The target may be an URL or a page-controller-function (not supported yet).
        The page_params are replaced in the URL.
        """

        target_url = target.format(**page_params)

        if self.request.is_xhr:
            js = "epfl.jump('" + target_url + "');"
            self.response.add_ajax_response(js)
        else:
            self.response.add_extra_content(jinja_helpers.Redirect(target_url))
